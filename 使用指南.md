## 目录
1. 1、shark入门；<br>
1. 1. 1.1 dataBase架构演变史；<br>
1. 1. 1.2 shark简介；<br>
1. 1. 1.3 常见的sharding中间件对比；<br>
1. 1. 1.4 从maven中央仓库下载shark的构件；<br>
1. 1. 1.5 下载并编译shark源码；<br>
1. 1. 1.6 shark的架构模型；<br>
1. 1. 1.7 shark的分片算法；<br>
1. 1. 1.8 单表查询支持的sql模板；<br>
1. 1. 1.9 shark使用过程中的一些注意事项；<br>
1. 1. 1.10 shark依赖的其它maven构件；<br>
- 2、配置读写分离操作；<br>
- 3、配置sharding操作；<br>
   - 3.1 一库一片算法；<br>
       - 3.1.1 片名连续的一库一片操作；<br>
       - 3.1.2 非片名连续的一库一片操作；<br>
   - 3.2 库内分片算法；<br>
       - 3.2.1 片名连续的库内分片操作；<br>
       - 3.2.2 非片名连续的库内分片操作；<br>
   - 3.3 配置sql文件与逻辑代码结构；<br>
   - 3.4 自动生成数据源文件；<br>
       - 3.4.1 自动生成c3p0数据源文件；<br>
       - 3.4.2 自动生成druid数据源文件；<br>
   - 3.5 多机sequenceid解决方案；<br>
       - 3.5.1 基于mysql生成全局唯一sequenceid；<br>
       - 3.5.2 基于zookeeper生成全局唯一sequenceid；<br>
   - 3.6 事物功能矩阵；<br>
- 4、使用配置中心；<br>
   - 4.1 基于zookeeper的资源配置中心；<br>
   - 4.2 基于redis3 cluster的资源配置中心；<br>
   - 4.2.1 使用版本号比对资源差异；<br>
   - 4.2.2 使用md5码比对资源差异；<br>
- 5、运维监控；<br>
   - 5.1 配置shark内置验证页面；<br>
- 6、HA方案；<br>




## 1、shark入门
本篇作为本文的开章，笔者衷心希望能够用干练的语句将shark的各个技术点尽可能的阐述清楚。

## 1.1 dataBase架构演变史
对于一个刚上线的互联网项目来说，由于前期用户活跃度并不大，并发量相对较小，因此企业一般都会选择将所有数据信息存放在单库中进行读/写操作。随着用户活跃度的不断提升，单库逐渐力不从心，这时DBA就会将数据库设置为读写分离状态(一主一从/一主多从)，Master负责写，Slave负责读。按照二八定律，80%的操作更多是读，那么剩下的20%则为写，读写分离后，大大提升了单库无法支撑的负载压力。不过光靠读写分离并不会一劳永逸，随着用户活跃度再次提升，必然会遇见读/写瓶颈，因此到了这个阶段，DBA就需要做垂直分库。

所谓垂直分库，就是根据业务划分将原本冗余在单库中的数据表分拆，落到不同的业务库中，实现分而治之。垂直分库能够有效提升数据库的并发处理能力，但是单一业务的数据始终是落盘在单表中，理论上Mysql单表超过500W行时，读操作就会是瓶颈，哪怕重建索引，也无法解决数据暴增带来的检索缓慢，这同时是RDBMS类型数据库的特点，相对于Nosql数据库而言，由于底层存储架构不同，所以无法进行比较。因此到了这个阶段，DBA就需要做水平分区，也就是大家常说的sharding操作。

所谓水平分区，就是将原本冗余在单库中的业务表分拆为N个逻辑相连的子表(比如tab_0001、tab_0002、tab_0003、 tab_N...)，分别存储在不同的子库中，既然数据库可以根据业务拆分做垂直，那么自然也可以将单一业务逻辑的数据库再次做分库，这样又可以提升并行处理能力，比如tab_0000 存储1-10000的数据，而tab_0001存储10001-20000的数据。水平分区后，大大提升了单表的读性能。基于分库分表的设计，目前在国内一些大型网站中应用的非常普遍。比如阿里巴巴、京东、云集等。
