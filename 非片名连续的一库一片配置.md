```Xml
<aop:aspectj-autoproxy proxy-target-class="true" />
<!-- 自动扫描 -->
<context:component-scan base-package="com">
	<context:include-filter type="annotation"
		expression="org.aspectj.lang.annotation.Aspect" />
</context:component-scan>
<!-- 非片名连续的一库一片配置 -->
<bean id="jdbcTemplate" class="com.gxl.shark.core.shard.SharkJdbcTemplate">
	<constructor-arg name="isShard" value="true" />
	<property name="dataSource" ref="dataSourceGroup" />
	<property name="wr_index" value="r0w0" />
	<!-- 分片模式,false为库内分片模式,true为一库一表分片模式 -->
	<property name="shardMode" value="true" />
	<!-- 片名是否连续,true为片名连续,false为非片名连续 -->
	<property name="consistent" value="false" />
	<property name="dbRuleArray" value="#userinfo_test_id|email_hash# % 2" />
	<property name="tbSuffix" value="_0000" />
</bean>
<bean id="dataSourceGroup" class="com.gxl.shark.core.config.SharkDatasourceGroup">
	<property name="targetDataSources">
		<map key-type="java.lang.Integer">
			<entry key="0" value-ref="dataSource1" />
			<entry key="1" value-ref="dataSource2" />
		</map>
	</property>
</bean>
<bean class="com.gxl.shark.sql.PropertyPlaceholderConfigurer">
	<constructor-arg name="path" value="classpath:sql.properties" />
</bean>
```

上述程序示例中，使用的是一主一从的非片名连续的一库一片配置。主库一共是16个(16个子表，每个库包含子表数为1个)，那么自然从库也就是16 个，在SharkDatasourceGroup中一共会持有32个数据源，数据源索引为0-31。主从索引wr_index属性的比例是 “r16w0”，这也就意味着0-15都是主库，而16-31都是从库，Shark会根据这个索引来自动根据所执行的操作切换到对应的主从数据源上。属 性shardMode其实就是指明了需要Shark使用哪一种分片算法，true为一库一片，而false则为库内分片。

属性dbRuleArray指明了分库规则，“#userinfo_id|email_hash# % 16”指明了路由条件可能包括两个，分别为userinfo_id和email_hash。然后根据路由条件%dbSize即可计算出数据究竟应该落盘到 哪一个库的哪一个子表下。